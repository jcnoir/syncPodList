/* Utils.c generated by valac 0.19.0, the Vala compiler
 * generated from Utils.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
typedef struct _UtilsPrivate UtilsPrivate;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

struct _Utils {
	GObject parent_instance;
	UtilsPrivate * priv;
};

struct _UtilsClass {
	GObjectClass parent_class;
};


static gpointer utils_parent_class = NULL;

GType utils_get_type (void) G_GNUC_CONST;
enum  {
	UTILS_DUMMY_PROPERTY
};
gchar* utils_formatDate (gint64 date);
gint64 utils_now (void);
Utils* utils_new (void);
Utils* utils_construct (GType object_type);


gchar* utils_formatDate (gint64 date) {
	gchar* result = NULL;
	gint64 _tmp0_;
	GDateTime* _tmp1_;
	GDateTime* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	_tmp0_ = date;
	_tmp1_ = g_date_time_new_from_unix_local (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_date_time_format (_tmp2_, "%d-%m-%Y %H:%M:%S");
	_tmp4_ = _tmp3_;
	_g_date_time_unref0 (_tmp2_);
	result = _tmp4_;
	return result;
}


gint64 utils_now (void) {
	gint64 result = 0LL;
	GTimeVal timeVal = {0};
	GTimeVal _tmp0_;
	glong _tmp1_;
	g_get_current_time (&timeVal);
	g_get_current_time (&timeVal);
	_tmp0_ = timeVal;
	_tmp1_ = _tmp0_.tv_sec;
	result = (gint64) _tmp1_;
	return result;
}


Utils* utils_construct (GType object_type) {
	Utils * self = NULL;
	self = (Utils*) g_object_new (object_type, NULL);
	return self;
}


Utils* utils_new (void) {
	return utils_construct (TYPE_UTILS);
}


static void utils_class_init (UtilsClass * klass) {
	utils_parent_class = g_type_class_peek_parent (klass);
}


static void utils_instance_init (Utils * self) {
}


GType utils_get_type (void) {
	static volatile gsize utils_type_id__volatile = 0;
	if (g_once_init_enter (&utils_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Utils), 0, (GInstanceInitFunc) utils_instance_init, NULL };
		GType utils_type_id;
		utils_type_id = g_type_register_static (G_TYPE_OBJECT, "Utils", &g_define_type_info, 0);
		g_once_init_leave (&utils_type_id__volatile, utils_type_id);
	}
	return utils_type_id__volatile;
}



